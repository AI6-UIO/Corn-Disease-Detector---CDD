# Image Processing Variables & Functions# ----------------------------------------------------------------------------import numpy as npimport torchfrom torchvision import modelsfrom PIL import Imagemean_datasets = torch.tensor([0.4375, 0.5055, 0.3819])      # mean training setstd_datasets  = torch.tensor([0.2156, 0.2261, 0.2154])     # stdev training setdef load_model_nocuda(path):    """Load a PyTorch model checkpoint"""    # Load in checkpoint    checkpoint = torch.load(path, map_location=torch.device('cpu'))    model = models.resnet50(pretrained=True)        # Make sure to set parameters as not trainable    for param in model.parameters():        param.requires_grad = False    model.fc = checkpoint['fc']    # Load in the state dict    model.load_state_dict(checkpoint['state_dict'])    #total_params = sum(p.numel() for p in model.parameters())    #print(f'{total_params:,} total parameters.')    #total_trainable_params = sum(    #    p.numel() for p in model.parameters() if p.requires_grad)    #print(f'{total_trainable_params:,} total gradient parameters.')    # Move to gpu    #if multi_gpu:    #    model = nn.DataParallel(model)    #if train_on_gpu:    #    model = model.to('cuda')    # Model basics    model.class_to_idx = checkpoint['class_to_idx']    model.idx_to_class = checkpoint['idx_to_class']    model.epochs = checkpoint['epochs']    # Optimizer    optimizer = checkpoint['optimizer']    optimizer.load_state_dict(checkpoint['optimizer_state_dict'])    return model, optimizerdef process_image(image_path):    """Process an image path into a PyTorch tensor"""    # Resize & Center crop    image = Image.open(image_path)    img = image.resize((256, 256))    width, height, new_width, new_height = 256, 256, 224, 224     left = (width - new_width) / 2    top = (height - new_height) / 2    right = (width + new_width) / 2    bottom = (height + new_height) / 2    img = img.crop((left, top, right, bottom))        # to numpy, transpose color dimension and normalize    img = np.array(img).transpose((2, 0, 1)) / 256        # standardization:     means = np.array(mean_datasets).reshape((3, 1, 1))    stds = np.array(std_datasets).reshape((3, 1, 1))    img = img - means    img = img / stds        # to pytorch tensor    img_tensor = torch.Tensor(img)    return img_tensordef predict_nocuda(image_path, model, topk=3):    """Make a prediction for an image using a trained model. No CUDA.    Only returns probabilities vector and categories vector."""    img_tensor = process_image(image_path)                  # to pytorch tensor    img_tensor = img_tensor.view(1, 3, 224, 224)    with torch.no_grad():                                   # Set to evaluation        #model.eval()        out = model(img_tensor)               # Model outputs log probabilities        ps = torch.exp(out)        topk, topclass = ps.topk(topk, dim=1)       # Find the topk predictions        top_classes = [                              # Actual classes and probs            model.idx_to_class[class_] for class_ in topclass.cpu().numpy()[0]        ]        top_p = topk.cpu().numpy()[0]        return top_p, top_classes